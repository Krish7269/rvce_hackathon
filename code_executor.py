"""Secure execution environment for analytics code generated by Gemini."""

from __future__ import annotations

import json
import logging
import os
import shutil
import subprocess
import sys
import tempfile
import textwrap
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional

LOGGER = logging.getLogger(__name__)

try:  # pragma: no cover - optional dependency
    from RestrictedPython import compile_restricted
except ImportError:  # pragma: no cover - optional dependency
    compile_restricted = None  # type: ignore

try:  # pragma: no cover - platform specific
    import resource
except ImportError:  # pragma: no cover - windows path
    resource = None  # type: ignore


DEFAULT_TIMEOUT = 30
DEFAULT_MEMORY_MB = 512


@dataclass
class ExecutionResult:
    success: bool
    output: str
    visualization: Optional[str]
    data: Dict
    error: Optional[str] = None
    duration_seconds: float = 0.0


class ExecutionSecurityError(RuntimeError):
    """Raised when code fails static security checks."""


class CodeExecutor:
    """Runs generated analytics code with sandboxing, logging, and reporting."""

    def __init__(self, timeout: int = DEFAULT_TIMEOUT, memory_limit_mb: int = DEFAULT_MEMORY_MB):
        self.timeout = timeout
        self.memory_limit_mb = memory_limit_mb

    def _validate_with_restricted_python(self, code: str) -> None:
        if compile_restricted:
            try:
                compile_restricted(code, filename="<generated>", mode="exec")
            except Exception as exc:  # pragma: no cover - dependent on library
                raise ExecutionSecurityError(f"RestrictedPython validation failed: {exc}") from exc
        else:
            LOGGER.debug("RestrictedPython not installed; skipping deep validation.")

        forbidden = ("import os", "import subprocess", "open(", "requests", "urllib")
        lowered = code.lower()
        for token in forbidden:
            if token in lowered:
                raise ExecutionSecurityError(f"Forbidden operation detected: {token}")

    def _prepare_script(self, code: str, workdir: Path) -> Path:
        script_path = workdir / "analysis_script.py"
        prolog = textwrap.dedent(
            """
            import os
            os.environ.setdefault("MPLBACKEND", "Agg")
            """
        ).strip()
        full_code = f"{prolog}\n\n{code}"
        script_path.write_text(full_code, encoding="utf-8")
        return script_path

    def _restricted_env(self) -> Dict[str, str]:
        safe_env = {key: value for key, value in os.environ.items() if key.startswith("PYTHON") or key in {"PATH"}}
        safe_env.update(
            {
                "PYTHONHASHSEED": "0",
                "PYTHONSAFEPATH": "",
                "PYTHONNOUSERSITE": "1",
                "MPLBACKEND": "Agg",
            }
        )
        return safe_env

    def _parse_result_payload(self, output: str) -> Dict:
        marker = "__RESULT__:"
        for line in reversed(output.strip().splitlines()):
            if line.startswith(marker):
                payload = line[len(marker):].strip()
                try:
                    return json.loads(payload)
                except json.JSONDecodeError:
                    return {"raw": payload}
        return {}

    def _preexec_fn(self):
        if not resource:
            return None

        def limit_resources():
            soft = hard = self.memory_limit_mb * 1024 * 1024
            resource.setrlimit(resource.RLIMIT_AS, (soft, hard))
            resource.setrlimit(resource.RLIMIT_DATA, (soft, hard))

        return limit_resources

    def execute_analysis_code(self, code: str, sandbox_root: Optional[str] = None) -> ExecutionResult:
        self._validate_with_restricted_python(code)

        sandbox_path = Path(sandbox_root) if sandbox_root else Path(tempfile.mkdtemp(prefix="analytics_sbx_"))
        sandbox_created = sandbox_root is None
        chart_path = sandbox_path / "chart.png"

        start = time.perf_counter()
        try:
            script_path = self._prepare_script(code, sandbox_path)
            cmd = [sys.executable, "-I", str(script_path)]
            proc = subprocess.run(
                cmd,
                cwd=sandbox_path,
                env=self._restricted_env(),
                capture_output=True,
                text=True,
                timeout=self.timeout,
                preexec_fn=self._preexec_fn(),
            )
            duration = time.perf_counter() - start
            output = proc.stdout.strip()
            stderr = proc.stderr.strip()
            success = proc.returncode == 0
            if not success:
                return ExecutionResult(
                    success=False,
                    output=output,
                    visualization=str(chart_path) if chart_path.exists() else None,
                    data=self._parse_result_payload(output),
                    error=stderr or f"Process exited with {proc.returncode}",
                    duration_seconds=duration,
                )

            data = self._parse_result_payload(output)
            return ExecutionResult(
                success=True,
                output=output,
                visualization=str(chart_path) if chart_path.exists() else None,
                data=data,
                duration_seconds=duration,
            )
        except subprocess.TimeoutExpired as exc:
            return ExecutionResult(
                success=False,
                output=exc.stdout or "",
                visualization=str(chart_path) if chart_path.exists() else None,
                data={},
                error=f"Execution timed out after {self.timeout}s",
                duration_seconds=self.timeout,
            )
        except ExecutionSecurityError as exc:
            return ExecutionResult(
                success=False,
                output="",
                visualization=None,
                data={},
                error=str(exc),
                duration_seconds=0.0,
            )
        finally:
            if sandbox_created:
                shutil.rmtree(sandbox_path, ignore_errors=True)


def execute_analysis_code(code: str, sandbox_root: Optional[str] = None) -> ExecutionResult:
    executor = CodeExecutor()
    return executor.execute_analysis_code(code, sandbox_root=sandbox_root)


